////////////////////////////////////////////////////////////////////////////////
//                                    BNF2C
//
// This file is distributed under the 4-clause Berkeley Software Distribution
// License. See LICENSE for details.
////////////////////////////////////////////////////////////////////////////////
#include "Rule.h"

////////////////////////////////////////////////////////////////////////////////
Rule::Rule(const std::string & name)
: name(name), numRule(-1)
{
}

////////////////////////////////////////////////////////////////////////////////
void Rule::addSymbol(const Symbol & symbol)
{
    symbols.push_back(symbol);
}

////////////////////////////////////////////////////////////////////////////////
void Rule::addSymbol(Symbol && symbol)
{
    symbols.push_back(symbol);
}

////////////////////////////////////////////////////////////////////////////////
SymbolList Rule::remainingSymbolsAfter(SymbolList::const_iterator symbol) const
{
    return { symbol + 1, symbols.end() };
}

////////////////////////////////////////////////////////////////////////////////
bool Rule::operator ==(const Rule & rule) const
{
    if(&rule == this)
       return true;

    return (name == rule.name) && (symbols == rule.symbols);
}

////////////////////////////////////////////////////////////////////////////////
bool Rule::operator !=(const Rule & rule) const
{
    return !(*this == rule);
}

////////////////////////////////////////////////////////////////////////////////
std::ostream & operator <<(std::ostream & os, const Rule & rule)
{
    os << "<" << rule.name << "> ::=";

    for(SymbolList::const_iterator it = rule.symbols.begin(); it != rule.symbols.end(); ++it)
        os << " " << *it;

    return os;
}
